(* ========================================================================= *)
(* Dictionaries on nums.                                                     *)
(* ========================================================================= *)

let ZERODICT = new_definition
  `ZERODICT (v:V) = (0 => v)`;;

let LOOKUP_ZERODICT = prove
 (`!k v:V. LOOKUP (ZERODICT v) k = if k = 0 then SOME v else NONE`,
  REWRITE_TAC[ZERODICT; LOOKUP_PAIRDICT]);;

let NODEDICT = new_definition
  `NODEDICT d0 d1 : (num,V)dict =
   Dict (\k. LOOKUP (if EVEN k then d0 else d1) (k DIV 2))`;;

let LOOKUP_NODEDICT = prove
 (`!d0 d1:(num,V)dict k.
     LOOKUP (NODEDICT d0 d1) k = LOOKUP (if EVEN k then d0 else d1) (k DIV 2)`,
  REWRITE_TAC[NODEDICT; LOOKUP]);;

let LOOKUP_NUMDICT = prove
 (`(!k. LOOKUP (EMPTYDICT:(num,V)dict) k = NONE) /\
   (!v:V. LOOKUP (ZERODICT v) _0 = SOME v) /\
   (!v:V n. LOOKUP (ZERODICT v) (BIT0 n) = LOOKUP (ZERODICT v) n) /\
   (!v:V n. LOOKUP (ZERODICT v) (BIT1 n) = NONE) /\
   (!d0 d1:(num,V)dict. LOOKUP (NODEDICT d0 d1) _0 = LOOKUP d0 _0) /\
   (!d0 d1:(num,V)dict n. LOOKUP (NODEDICT d0 d1) (BIT0 n) = LOOKUP d0 n) /\
   (!d0 d1:(num,V)dict n. LOOKUP (NODEDICT d0 d1) (BIT1 n) = LOOKUP d1 n)`,
  REWRITE_TAC[LOOKUP_EMPTYDICT; LOOKUP_ZERODICT; LOOKUP_NODEDICT] THEN
  REWRITE_TAC[REWRITE_CONV[NUMERAL] `0`; ARITH_EQ; ARITH_EVEN] THEN
  SUBGOAL_THEN `!n. BIT0 n DIV 2 = n /\ BIT1 n DIV 2 = n`
    (fun th -> REWRITE_TAC[th]) THENL
  [GEN_TAC THEN
   GEN_REWRITE_TAC (BINOP_CONV o LAND_CONV o LAND_CONV) [BIT0; BIT1] THEN
   ARITH_TAC;
   ALL_TAC] THEN
  MP_TAC (NUM_DIV_CONV `0 DIV 2`) THEN SIMP_TAC[NUMERAL]);;

let GET_NUMDICT = prove
 (`(!k. GET (EMPTYDICT:(num,V)dict) k = GETOPTION NONE) /\
   (!v:V. GET (ZERODICT v) _0 = v) /\
   (!v:V n. GET (ZERODICT v) (BIT0 n) = GET (ZERODICT v) n) /\
   (!v:V n. GET (ZERODICT v) (BIT1 n) = GETOPTION NONE) /\
   (!d0 d1:(num,V)dict. GET (NODEDICT d0 d1) _0 = GET d0 _0) /\
   (!d0 d1:(num,V)dict n. GET (NODEDICT d0 d1) (BIT0 n) = GET d0 n) /\
   (!d0 d1:(num,V)dict n. GET (NODEDICT d0 d1) (BIT1 n) = GET d1 n)`,
  REWRITE_TAC[GET; LOOKUP_NUMDICT; GETOPTION]);;

let NUMDICT_UPDATE = prove
 (`(!v:V. UPDATE EMPTYDICT _0 v = ZERODICT v) /\
   (!v:V n. UPDATE EMPTYDICT (BIT0 n) v =
            NODEDICT (UPDATE EMPTYDICT n v) EMPTYDICT) /\
   (!v:V n. UPDATE EMPTYDICT (BIT1 n) v =
            NODEDICT EMPTYDICT (UPDATE EMPTYDICT n v)) /\
   (!u v:V. UPDATE (ZERODICT u) _0 v = ZERODICT v) /\
   (!u v:V n. UPDATE (ZERODICT u) (BIT0 n) v =
              NODEDICT (UPDATE (ZERODICT u) n v) EMPTYDICT) /\
   (!u v:V n. UPDATE (ZERODICT u) (BIT1 n) v =
              NODEDICT EMPTYDICT (UPDATE (ZERODICT u) n v)) /\
   (!d0 d1 v:V. UPDATE (NODEDICT d0 d1) _0 v = NODEDICT (UPDATE d0 _0 v) d1) /\
   (!d0 d1 n v:V. UPDATE (NODEDICT d0 d1) (BIT0 n) v =
                  NODEDICT (UPDATE d0 n v) d1) /\
   (!d0 d1 n v:V. UPDATE (NODEDICT d0 d1) (BIT1 n) v =
                  NODEDICT d0 (UPDATE d1 n v))`,

  REWRITE_TAC[DICT_LOOKUP_EXTENSION; LOOKUP_UPDATE] THEN
  CLAIM_TAC "bit0" `!n. BIT0 n DIV 2 = n` THENL [GEN_TAC THEN GEN_REWRITE_TAC (LAND_CONV o LAND_CONV) [BIT0] THEN ARITH_TAC; ALL_TAC] THEN
  CLAIM_TAC "bit1" `!n. BIT1 n DIV 2 = n` THENL [GEN_TAC THEN GEN_REWRITE_TAC (LAND_CONV o LAND_CONV) [BIT1] THEN ARITH_TAC; ALL_TAC] THEN
  REPEAT CONJ_TAC THEN REPEAT GEN_TAC THEN (COND_CASES_TAC THENL [POP_ASSUM SUBST_VAR_TAC THEN ASM_REWRITE_TAC[LOOKUP_EMPTYDICT; LOOKUP_ZERODICT; REWRITE_CONV[NUMERAL] `0`; LOOKUP_NODEDICT; ARITH_EVEN; LOOKUP_UPDATE]; ASM_REWRITE_TAC[LOOKUP_EMPTYDICT; LOOKUP_ZERODICT; REWRITE_CONV[NUMERAL] `0`; LOOKUP_NODEDICT; LOOKUP_UPDATE]])

  COND_CASES_TAC THEN REWRITE_TAC[LOOKUP_UPDATE; LOOKUP_EMPTYDICT]
  COND_CASES_TAC THEN ASM_REWRITE_TAC[]
  POP_ASSUM SUBST_VAR_TAC
  POP_ASSUM (K ALL_TAC)
  POP_ASSUM MP_TAC
  

  REWRITE_TAC[REWRITE_CONV[NUMERAL] `0`]
  

  REPEAT CONJ_TAC THEN REPEAT GEN_TAC THEN REPEAT (COND_CASES_TAC THEN POP_ASSUM MP_TAC THEN ASM_REWRITE_TAC[ARITH_EVEN; LOOKUP_EMPTYDICT; LOOKUP_ZERODICT; LOOKUP_UPDATE])


)